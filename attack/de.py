
#this is used to generate the attacking map based on differential envolution
#1. initialization with perturbations generated by BIM
#2. varation x_i(g+1) = x_{r1}(g)+F(x_{r2}(g)+x_{r3}(g))
#3. only maximun mape can survive
#4 repreat 2 and 3
#5. after a number of generations, compare the survivals time step by time step

from data_loader.data_utils import gen_batch
from utils.math_utils import evaluation
from os.path import join as pjoin

import tensorflow as tf
import numpy as np
import time

def global_impact(y,y_,theta=0.5):
    temp = np.abs(y[:,:,0]-y_[:,:,0])
    return np.size(temp[np.where(temp>theta)])

def multi_pred(sess, y_pred, seq, batch_size, n_his, n_pred, step_idx, dynamic_batch=True):
    '''
    Multi_prediction function.
    :param sess: tf.Session().
    :param y_pred: placeholder.
    :param seq: np.ndarray, [len_seq, n_frame, n_route, C_0].
    :param batch_size: int, the size of batch.
    :param n_his: int, size of historical records for training.
    :param n_pred: int, the length of prediction.
    :param step_idx: int or list, index for prediction slice.
    :param dynamic_batch: bool, whether changes the batch size in the last one if its length is less than the default.
    :return y_ : tensor, 'sep' [len_inputs, n_route, 1]; 'merge' [step_idx, len_inputs, n_route, 1].
            len_ : int, the length of prediction.
    '''
    pred_list = []
    for i in gen_batch(seq, min(batch_size, len(seq)), dynamic_batch=dynamic_batch):
        # Note: use np.copy() to avoid the modification of source data.
        test_seq = np.copy(i[:, 0:n_his + 1, :, :])
        step_list = []
        for j in range(n_pred):
            pred = sess.run(y_pred, feed_dict={'data_input:0': test_seq, 'keep_prob:0': 1.0})
            if isinstance(pred, list):
                pred = np.array(pred[0])
            test_seq[:, 0:n_his - 1, :, :] = test_seq[:, 1:n_his, :, :]
            test_seq[:, n_his - 1, :, :] = pred
            step_list.append(pred)
        pred_list.append(step_list)
    #  pred_array -> [n_pred, batch_size, n_route, C_0)
    pred_array = np.concatenate(pred_list, axis=1)
    return pred_array[step_idx], pred_array.shape[1]


def attacking_map(inputs, n, n_his, n_pred, load_path='./output/models/', noise_path='./output/ypred/noise_BIM_0007.npy'):
    '''
    Load and test saved model from the checkpoint.
    :param inputs: instance of class Dataset, data source for test.
    :param n_his: int, the length of historical records for training.
    :param n_pred: int, the length of prediction.
    :param load_path: str, the path of loaded model.
    '''
    start_time = time.time()
    
    # noise load
    noise = np.load(noise_path)
    print(f'noise loaded from {noise_path}')

    # model load
    model_path = tf.train.get_checkpoint_state(load_path).model_checkpoint_path

    test_graph = tf.Graph()

    with test_graph.as_default():
        saver = tf.train.import_meta_graph(pjoin(f'{model_path}.meta'))

    with tf.Session(graph=test_graph) as test_sess:
        saver.restore(test_sess, tf.train.latest_checkpoint(load_path))
        print(f'>> Loading saved model from {model_path} ...')

        pred = test_graph.get_collection('y_pred')

        step_idx = n_pred - 1

        x_test, x_stats = inputs.get_data('test'), inputs.get_stats()
        
        N = 3*n
        # Initialization for DE
        candidates = np.zeros((N, 1+n_his),dtype=float)
        candidates[:,0] = np.tile([i for i in range(n)],[int(N/n)])
        candidates[:,1:n_his+1] = np.tile(np.transpose(np.mean(noise,0),(1,0,2))[:,0:n_his,0],[int(N/n),1])
        candidates = candidates + 0.5*(np.random.rand(N, 1+n_his) - 0.5)
        
        #set parameters
        number_iteration = 5
        F_big = 0.2
        batch_size = 1000

        # variation
        for index_1 in range(number_iteration):
            print(f'========iteration:{index_1}========')
            index_r1 = np.floor(N*np.random.rand(N,3)).astype(int)
#            index_r2 = np.floor(10*n*np.random.rand(10*n)).astype(int)
#            index_r3 = np.floor(10*n*np.random.rand(10*n)).astype(int)
            new_candidates = candidates[index_r1[:,0],:] + F_big*(candidates[index_r1[:,1],:] + candidates[index_r1[:,2],:])
            new_candidates[:,0] = np.floor(new_candidates[:,0]%228)
            print('========new_candidates generated========')
            te_compare = np.zeros(4)
            for index_2 in range(N):
                # new candidate
                print(f'the current n_route is: {index_2}')

                x_test_ = np.copy(x_test)
                x_test_[:,0:n_his,int(new_candidates[index_2,0]),0] = x_test_[:,0:n_his,int(new_candidates[index_2,0]),0] + np.tile(new_candidates[index_2,1:n_his+1],[np.size(x_test_, 0),1])
                y_test, len_test = multi_pred(test_sess, pred, x_test_, batch_size, n_his, n_pred, step_idx)
#                evl = evaluation(x_test[0:len_test, step_idx + n_his, :, :], y_test, x_stats)
                evl = global_impact(x_test[0:len_test, step_idx + n_his, :, :], y_test)
                te_compare[0] = evl

                # father:1
                x_test_ = np.copy(x_test)
                x_test_[:,0:n_his,int(candidates[index_r1[index_2,0],0]),0] = x_test_[:,0:n_his,int(candidates[index_r1[index_2,0],0]),0] + np.tile(candidates[index_r1[index_2,0],1:n_his+1],[np.size(x_test_, 0),1])
                y_test, len_test = multi_pred(test_sess, pred, x_test_, batch_size, n_his, n_pred, step_idx)
#                evl = evaluation(x_test[0:len_test, step_idx + n_his, :, :], y_test, x_stats)

                evl = global_impact(x_test[0:len_test, step_idx + n_his, :, :], y_test)
                te_compare[1] = evl

                # father:2
                x_test_ = np.copy(x_test)
                x_test_[:,0:n_his,int(candidates[index_r1[index_2,1],0]),0] = x_test_[:,0:n_his,int(candidates[index_r1[index_2,1],0]),0] + np.tile(candidates[index_r1[index_2,1],1:n_his+1],[np.size(x_test_, 0),1])
                y_test, len_test = multi_pred(test_sess, pred, x_test_, batch_size, n_his, n_pred, step_idx)
#                evl = evaluation(x_test[0:len_test, step_idx + n_his, :, :], y_test, x_stats)

                evl = global_impact(x_test[0:len_test, step_idx + n_his, :, :], y_test)
                te_compare[2] = evl

                # father:3
                x_test_ = np.copy(x_test)
                x_test_[:,0:n_his,int(candidates[index_r1[index_2,2],0]),0] = x_test_[:,0:n_his,int(candidates[index_r1[index_2,2],0]),0] + np.tile(candidates[index_r1[index_2,2],1:n_his+1],[np.size(x_test_, 0),1])
                y_test, len_test = multi_pred(test_sess, pred, x_test_, batch_size, n_his, n_pred, step_idx)
#                evl = evaluation(x_test[0:len_test, step_idx + n_his, :, :], y_test, x_stats)

                evl = global_impact(x_test[0:len_test, step_idx + n_his, :, :], y_test)
                te_compare[3] = evl
                
                variation_index = np.argmax(te_compare)
                if variation_index == 0:
                    candidates[index_2,:] = np.copy(new_candidates[index_2,:])
                if variation_index == 1:
                    candidates[index_2,:] = np.copy(candidates[index_r1[index_2,0],:])
                if variation_index == 2:
                    candidates[index_2,:] = np.copy(candidates[index_r1[index_2,1],:])
                if variation_index == 3:
                    candidates[index_2,:] = np.copy(candidates[index_r1[index_2,2],:])
            print(candidates[:,0])
        print(f'Model Test Time {time.time() - start_time:.3f}s')
        np.save('./output/ypred/candidates_attacking_map',candidates)
